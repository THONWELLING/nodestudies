# nodestudies

    		PÁGINA NÃO ENCONTRADA

PARA CRIAR UMA "rota de pàgina nâo encontrada" DENTRO DO SERVIDOR LOGO DEPOIS DA INSTÂNCIA DAS ROTAS:server>use(mainRoutes)
ESPECIFICAMOS O CAMINHO PARA QUANDO A PÁGINA NÃO FOR ENCONTRADA.
server>use((req: Request, res: Response) => {
res.status(404).send('Página não encontrada')
}
)
OQUE ESTPÁ ACONTECENDO AQUI??? O NOSSO SERVIDOR ENTRA DENTRO DE server.use(mainRoutes) E TEM ACESSO AS ROTAS ENTÃO ELE PROCURA
DENTRO DO ARQUIVO SE TEM ALGUMA ROTA IGUAL A QUE FOI BUSCADA SE ELE NÃO ENCONTAR ELE PASSA PARA A PRÓXIMA LINHA DE INSTRUÇÃO QUE NO
NOSSO CASO É A PÁGINA NÃO ENCONTRADA.

# PASTA PUBLICA E ARQUIVOS ESTÁTICOS

    A PASTA public É ONDE COLOCAMOS ARQUIVOS PUBLICOS OU SEJA ARQUIVOS QUE VÃO ESTAR DISPONÍVEL PARA TODOS

E QUE PODERÁ SER ACESSADO DIRETAMENTE PELA URL.
PARA ISSO, LOGO APÓS A INSTÂNCIA DO express DIGITAMOS:

    	server.use(express.static('public'))

    ESSA LINHA DE CÓDIGO TRANSFORMA ESTA PASTA EM UMA PASTA ESTÁTICA.PORÉM DA FORMA COMO FOI ESCRITA ESSA LINHA DE CÓDIGO

ESSE CAMINHO SÓ VAI FUNCIONAR QUANDO FOR EXECUTADO DE DENTRO DA RAIZ DO PROJETO.
ISSO QUER DIZER QUE QUNDO TENTARMOS EXECUTAR UMA BUSCA DE UM ARQUIVO DENTRO DESTA PASTA MAIS ESTIVERMOS EM OUTRO LOCAL
DENTRO DO NOSSO HD NA RAIZ DO HD POR EXEMPLO ELE VAI RETORNAR 'Página não encontrada'.PORQUE ELE VAI PROCURAR ESSA PASTA NA RAIZ
DO HD E NÃO VAI ENCONTRAR.
PARA EVITAR ESSE TIPO DE PROBLEMA NÓS PRECISAMOS DEFINIR O CAMINHO ABSOLUTO DA PASTA OU ARQUIVO.
PARA TAL VAMOS USAR UMA BIBLIOTECA QUE JA VEM JUNTO COM O express CHAMADA path...
PRECISAMOS IMPORTAR DENTRO DO NOSSO PROJETO EX: import path from 'path'

LOGO DEPOIS DISSO VAMOS USAR O COMANDO path.join() DENTRO DE UM console.log() ESSE COMANDO TEM 2 PARÂMETROS

- NO PROMEIRO COLOCAMOS UMA CONSTANTE QUE VEM JUNTO COM O NODE \_\_dirname.

\_\_dirname VAI ESPECIFICAR O DIRETÓRIO DO ARQUIVO QUE ESTAMOS EXECUTANDO NO NOSSO CASO server.ts QUE ESTÁ DENTRO DA PASTA src

- NO SEGUNDO PARÂMETRO COLOCAMOS A PASTA QUE QUEREMOS ESPECIFICAR. SE O SEU ARQUIVO server.ts(OU QUALQUER NOM QUE VOCÊ TENHA COLOCADO)
  ESTIVER FORA DA PASTA src OU SEJA SE ELE ESTIVER NA RAIZ DO PROJETO A LINHA D CÓDIGO FICARÁ ASSIM:

console>log(path.join(\_\_dirname, 'public'))
SE O SEU ARQUIVO server.ts(OU QUALQUER NOM QUE VOCÊ TENHA COLOCADO)
ESTIVER DENTRO DA PASTA src OU SEJA SE ELE NÃO ESTIVER NA RAIZ DO PROJETO VOCÊ PRECISA VOLTAR UMA PASTA E ENTAR NA PASTA public A LINHA D CÓDIGO FICARÁ ASSIM:

console>log(path.join(\_\_dirname, '../public'))

DEPOIS DISSO FEITO NÃO IMPORTA ONDE INICIAMOS A NOSSA EXECUÇÃO A PASTA/ARQUIVO SERÁ ENCONTRADA.

===========================================================================

# VIEW ENGINE

    VIEW ENGINE NaDA MAIS É DO QUE BIBLIOTECAS USADAS PARA DINAMIZAR AS PÁGINAS DA APLICAÇÃO.

NO NOSSO CASO VAMOS ESTAR USANDO O mustache.
PARA COMEÇAR INSTALAMOS A BIBLIOTECA JÁ COM O SUPORTE AO FRAMEWORK QUE ESTAMOS UTILIZANDO "express" npm install mustache_express
LOGO EM SEGUIDA INSTALAMOS OS TYPES DA BIBLIOTECA npm install @types/mustache-express.
ENTÃO IMPORTAMOS A BIBLIOTECA
import mustache from"mustache_express"

## AGORA CONFIGURAMOS PARA A UTILIZAÇÃO

1º LOGO DEPOIS DE CRIAR O SERVIDOR PARA SETAR O MUSTACHE COMO O NOSSO VIEW ENGINE DIGITAMOS O SEGUINTE CÓDIGO:
server.set('view engine', 'mustache')

2º PARA DIZER PARA O NOSSO express ONDE ESTARÃO OS ARQUIVOS HTML NO NOSSO PROJETO
ENTÃO PARA ISSO CRIAMOS UMA NOVA PASTA DENTRO DE src CHAMADA views E DENTRO DESTA PASTA COLOCAMOS OS ARQUIVOS HTML.E PARA ISSO VAMOS USAR O CAMINHO ABSOLUTO DESTA PASTA:
USANDO O path.join()
server.set('views', path.join(\_\_dirname, 'views'))

3º AGORA BASTA USARMOS O mustache DE FATO DEFININDO ELE COMO A ENGINE DE FATO E PASSANDO COMO 2º PARÂMETRO A FUNÇÃO mustache() QUE IMPORTAMOS LA EM CIMA "LEMBRANDO QUE
PODEMOS IMPORTAR COM QUALQUER OUTRO NOME".
server.engine('mustache', mustache());

===========================================================================

# TRABALHANDO COM CONTROLLERS

    O CONTROLLER TALVEZ SEJA O MAIS IMPORTANTE DENTRO DO CONCEITO MVC PORQUE É ELE QUEM ORGANIZA TODO O PROCESSO ELE É O GERENCIADOR

POR EXEMPLO: TEMOS UMA ROTA CRIADA DENTRO DO ARQUIVO routes.ts COMO VEMOS ABAIXO.

    router.get('/', (req: Request, res: Response) => {
     		let age: number = 90;
    		let showOld: boolean = false;

if(age > 50) {
showOld = true;
}
res.render('pages/home', {
name: 'Bonieky',
lastName: 'Lacerda',
showOld,
products: [
{title: 'Produto X', price: 10},
{title: 'Produto Y', price: 15},
{title: 'Produto W', price: 20},
{title: 'Produto G', price: 5}
],
frasesDoDia: []
});
}

    OBSERVE QUE A ROTA TEM COMO PRIMEIRO PARÂMETRO O ENDEREÇO DA ROTA  NO NOSSO CASO(/) QUE REPRESENTA A PÁGINA HOME E,

NO SEGUNDO PARÂMETRO TEMOS UMA FUNÇÃO QUE SERÁ EXECUTADA QUANDO ESSA ROTA FOR ACESSADA.
ESSA FUNÇÃO É RETIRADA DA ROTA E É CRIADO UMA PASTA controllers E DENTRO DELA UM ARQUIVO homeController.ts E TODA A FUNÇÃO ACIMA QUE ESTAVA
ESCRITA DENTRO DA ROTA NÓS ESCREVEMOS DENTRO DESTE ARQUIVO. E EXPORTAMOS ELE COMO VEMOS ABAIXO:

import { Request, Response } from 'express';

export const home = async (req: Request, res: Response)=>{
let age: number = 90;
let showOld: boolean = false;

    if(age > 50) {
        showOld = true;
    }

    res.render('pages/home', {
        name: 'Thonwelling',
        lastName: 'Dani',
        showOld,
        products: list,
        frasesDoDia: [],

    });

};

    E IMPORTAMOS  O controller DENTRO DO ARQUIVO DE ROTAS E NO SEGUNDO PARÂMETRO DA NOSSA ROTA COLOCAMOS A FUNÇÃO nomeDoController.nomeDoArquivo

    O IDEAL EM TERMOS DE CONTROLLERS PARA DECIDIR SE VAMOS CRIAR UM ARQUIVO OOU VÁRIOS ARQUIVOS CONTROLLERS É:

GERALMENTE CRIAMOS UM ARQUIVO DE CONTROLLERS PARA CADA GRUPO DE INFORMAÇÕES.EX: SUPONDO QUE TEMOS UMA LOJA VIRTUAL E TEMOS
LÁ A PÁGINA home ELA POR SÍ SÓ JA TEM OS PROPRIOS MECANISMOS DE PÁGINA home, DEPOIS EU TENHO PÁGINAS INSTITUCIONAIS COMO :
termos de uso, página de contato, politica de privacidade OU SEJA ESSAS SÃO PÁGINAS QUE VÃO CONTER APENAS INFORMAÇÕES BASICAMENTE
ESSAS PÁGINAS TEM UM MESMO GRUPO DE INFORMAÇÕES UMA MESMA MECÂNICA PODEMOS JUNTAR TODAS EM UM ÚNICO CONTROLLER ENTÃO TEREMOS 2 ARQUIVOS
DE CONTROLLER homeController E O infoController SE TIVESSEMOS ALGUMAS PÁGINAS RELACIONADAS A PRODUTOS POR EXEMPLO TERIAMOS UM controller
PARA ESSE GRUPO DE PÁGINAS TAMBÉM.
EM RESUMO TEMOS UM controller PARA TUDO QEU FOR RELACIONADO AO USUÁRIO POR EXEMPLO
OUTRO controller PARA TUDO RELACIONADO A PRODUTO.
OUTRO AINDA PARA COISAS RELACIONADAS A PÁGINAS DE INFORMAÇÕES
E ASSIM POR DIANTE.

===========================================================================

# TRABALHANDO COM MODELS

    OS MODELS SÃO RESPONSÁVEIS POR PROCESSAR AS INFORMAÇÕES E DADOS.

OS MODELS SÃO CRIADOS DE ACORDO COM OS ITENS QUE TEMOS OU TEREMOS EM NOSSA APLICAÇÃO EX:
EM UMA LOJA VIRTUAL TEREMOS UM MODEL RESPONSÁVEL POR LIDAR COM PRODUTOS (NÃO VAI SER UM MODEL PARA CADA PRODUTO E SIM UM MODEL PARA LIDAR COM PRODUTOS)
OUTRO PARA LIDAR COM USUÁRIOS.
NORMALMENTE O MODEL É CRIADO COM O NOME NO SINGULAR Product.ts (PARA PRODUTOS) POR QUE PODEMOS LIDAR COM 1 USUÁRIO OU COM VÁRIOS E A PRIMEIRA LETRA É MAIUSCULA
EX:
type Product = {
title: string,
price: number
};
//CRIAMOS AQUI UMA VARIÁVEL GENÉRICA PARA SUBSTITUIR O(S) BANCO(S) DE DADOS (NO NOSSO CASO ATUAL NÃO CONECTAMOS AINDA COM NENHUM BANCO DE DADOS)
const data: Product[] = [
{title: 'Produto X', price: 10},
{title: 'Produto Y', price: 15},
{title: 'Produto W', price: 20},
{title: 'Produto G', price: 5}
];

export const Product = {
// FUNÇÃO PARA PEGAR TODOS OS PRODUTOS QUE TEM NO BANCO DE DADOS
getAll: (): Product[] => {
return data;
},
// FUNÇÃO PARA FILTRAR POR PREÇO
getFromPriceAfter: (price: number): Product[] => {
return data.filter(item => item.price >= price);
}
};
PARA USAR ESSE MODEL IMPORTAMOS AGORA ELE DENTRO DO controller

import { Product } from '../models/Product';

AGORA PODEMOS USAR O Product EM QUALQUER FUNÇÃO QUE TEMOS DENTRO DO controller POR EX:

export const home = async (req: Request, res: Response)=>{

    let age: number = 90;
    let showOld: boolean = false;

    if(age > 50) {
        showOld = true;
    }

    let list = Product.getAll();

    res.render('pages/home', {
        name: 'Thonwelling',
        lastName: 'Dani',
        showOld,
        products: list,
        frasesDoDia: []
    });

};

===========================================================================

# OQUE É ORM???

O ORM È UMA FORMA DE INTERCONECTAR A APLICAÇÃO COM O BANCO DE DADOS.
ONDE NÓS ENSINAMOS A ELE COMO FUNCIONA O BANCO DE DADOS E A PARTIR DAÍ ELE CONSEGUE MANIPULAR

===========================================================================

# SEQUELIZE

## sequelize

é um ORM promise-based ou seja é baseado em promessas fazemos uma solicitação e aguardamos o resultado.
SEQUELIZE TEM SUPORTE AO TYPESCRIPT PORÉM NÃO É NECESSÁRIO QUE USEMOS MUITO TYPESCRIPT POR QUE SE NÃO VAMOS TER QUE REPETIR MUITAS VEZES PARTES DO CÓDIGO
EXEMPLO: NO BANCO DE DADOS b7web TEM A TABELA users QUE TEM O CAMPO
firstName: string
lastName: string
password: string
age: number
ESSAS INFORMAÇÕES ESTÃO SENDO PASSADAS PARA O sequelize ...PORÉM, TEMOS QUE PASSAR TAMBÉM ESSAS INFORMAÇÕES NA TIPAGEM DO TYPESCRIPT ENTÃO SE APLICARMOS MUITO TYPESCRIPT
JUNTO COM O SEQUELIZE FICARIA REPETITIVO E MUITAS VEZES NO MESMO ARQUIVO.
PARA UTILIZAR SEQUELIZE COM TYPESCRIPT PRECISAREMOS DOS SEGUINTES TYPES:

npm install -D @types/sequelize @types/validator

===========================================================================

# CONECTANDO COM O BANCO DE DADOS POSTGRESQL

    PRIMEIRA COISA  PRECISAMOS INSTALAR 2 BIBLIOTECAS QUE POSSIBILITARÃO AO SEQUELIZE A MANIPULAÇÃO DO BANCO D DADOS (POSTGRESQL).SÃO ELAS:

npm install pg pg-hstore

    NAS VARIÁVEIS DE AMBIENTE

    	PG_DB=users  => O NOME DO BANCO D DADOS
    	PG_USER=postgres  => O NOME DO USUÁRIO DO BANCO
    	PG_PASSWORD=ThDa04112016 => A SENHA DO BANCO
    	PG_PORT=5432 => A PORTA EM QUE O BANCO ESTÁ RODANDO


    AGORA VAMOS CRIAR A CONEXÃO COM O BANCO DE DADOS DE FORMA QUE EU CRIE A CONEXÃO EM UM LOCAL SÓ E POSSA USAR EM QUALQUER LUGAR DA MINHA APLICAÇÃO QUE EU QUEIRA USAR O BANCO

    DENTRO DE src CRIE UMA PASTA instances E DENTRO O ARQUIVO pg.ts

import { Sequelize } from 'sequelize'
import dotenv from 'dotenv'

dotenv.config()

export const sequelize = new Sequelize(
process.env.PG_DB as string, => 1º parâmetro é o nome do banco de dados
process.env.PG_USER as string, => 2º parâmetro é o nome de usuário do banco de dados
process.env.PG_PASSWORD as string, => 3º parâmetro é a senha do banco de dados
{ => O 4º parâmetro é um objeto com configurações especificas
dialect: 'postgres', => qual é o banco de dados que usaremos
port: parseInt(process.env.PG_PORT as string)
}
)

    NOTE QUE TIVEMOS QUE FAZER ALGUNS ASSERTIONS NAS INFORMAÇÕES PASSADAS (as string).ISSO PORQUE O TYPSCRIPT AVISA QUE A INFORMAÇÃO PURA (SEM O ASSERTION as string) PODE RETORNAR

TANTO UMA string QUANTO PODE SER undefined E ISSO O typescript NÃO ACEITA, POR ESSE MOTIVO PRECISAMOS FAZE RUM ASSERTION INFORMANDO O typescript DE QUE O RETORNO DA VARIÁVEL DE AMBIENTE
SERÁ UMA string.
NOTE TAMBÉM QUE NA port: PRECISAMOS COLOCAR DENTRO DE UM parseInt(), ISSO PORQUE A PROPRIEDADE port ESPERA UM number OU UM undefined...E TODA VARIÁVEL DE AMBIENTE MESMO QUE TENHA
NUMEROS ELA OS RETORNA EM FORMA DE string ENTÃO TEMOS QUE POR DENTRO DE UM parseInt() PARA TRANSFORMAR EM UM INTEIRO.

===========================================================================

# CRIANDO O MODEL COM SEQUELIZE

    DENTRO  DE src CRIE A PASTA models E DENTRO DE models CRIE O ARQUIVO User.ts...
    PARA CRIAR O MODEL VAMOS PRECISAR IMPORTAR 2 TYPES QUE VEM DIRETO DO sequelize O Model EO DataTypes


    import { Model, DataTypes } from 'sequelize';
    import { sequelize } from '../instances/pg';


     PARA CRIAR O TYPE ESPECÍFICO PARA O USUÁRIO NO PRECISAREMOS USAR O interface PORQUE PRECISAREMOS ESTENDER COM O TYPE DO MODEL DO PRÓPRIO SEQUELIZE,

OU SEJA PRECISAMOS ESTENDER OS TYPES DO Model QUE VEM DO sequelize COM O model QUE ESTAMOS CRIANDO.

export interface UserInstance extends Model {
id: number;
firstname: string;
age: number;
lastname: string;
}

# ENSINANDO O SEQUELIZE A MANIPULAR O BANCO DE DADOS

1º PARÂMETRO COLOCAMOS O NOME DO MODEL NO CASO É User
2º PARÂMETRO COLOCAMOS ALGUMAS CONFIGURAÇÕES ONDE DIZEMOS PARA O SEQUELIZE OS CAMPOS DA TABELA NO BANCO DE DADOS.
3º PARÂMETRO COLOCAMOS PROPRIEDADES ESPECÍFICAS PARA O PRÓPRIO SEQUELIZE

export const User = sequelize.define<UserInstance>("User", {
id: {
primaryKey: true,
type: DataTypes.INTEGER
},
firstname: {
type: DataTypes.STRING
},
lastname: {
type: DataTypes.STRING
},
age: {
type: DataTypes.INTEGER,
defaultValue: 18
}
}, {
tableName: 'users', // COLOCAMOS AQUI O NOME EXATO DA TABELA DO BANCO DE DADOS
timestamps: false // QUI NÓS DETERMINAMOS QUE NÃO EXISTE OS CAMPOS createdAt E O updatedAt
});

===========================================================================

# CONSULTANDO DADOS ATRAVÉS DO MODEL

    PRIMEIRAMENTE PRECISAMOS IMPORTAR O model DENTRO DO NOSSO controller...

    import { User } from '../models/User';


    	PARA PEGAR TODOS OS USUÁRIOS DO BANCO DE DADOS USAMOS O COMANDO findAll()...
    		let users = await User.findAll()


      PARA SELECIONAR OS DADOS QUE VAMOS PEGAR DO BANCO
    	  SUPONDO QUE A QUANTIDADE DE DADOS QUE VEM DO BANCO DE DADOS SEJA MUITO EXTENSA E NÃO VAMOS UTILIZAR TODAS NÃO PRECISAMOS PEGAR TODAS.ENTÃO PARA SELECIONARMOS

QUAIS INFORMAÇÕES QUEREMOS BUSCAR DO BANCO DE DADOS CONFIGURAMOS UM OBJETO DENTRO DA FUNÇÃO COMO ABAIXO:

    let users = await User.findAll({
       		 attributes: ['firstname', 'lastname']
    	})


    NO EXEMPLO ACIMA EU DISSE AO SEQUELIZE QUAL INFORMAÇÃO EU QUERO PEGAR.PODEMOS TAMBÉM DIZER QUAL INFORMAÇÃO  QUE EU NÃO QUERO PEGAR PARA ISSO NO attributes

AO INVÉS DE PASSAR AS INFORMAÇÕES DENTRO DE UM array PASSAMOS DENTRO DE UM OBJETO A PROPRIEDADE exclude: ['INFORMAÇÃO']COMO VEMOS ABAIXO:

let users = await User.findAll({
attributes: { exclude: [ 'id' ] }
})

PARA FAZER UMA FILTRAGEM USAMOS A PROPRIEDADE where E COLOCAMOS A CONDIÇÃO QUE PROCURAMOS
let users = await User.findAll({
where: { firstname: 'Dani', age: 14 }
})
NO CÓDIGO ACIMA QUANDO COLOCAMOS MAIS DE UMA CONDIÇÃO ESTAMOS FILTRANDO COM O OPERADOR CONDICIONAL &&... OU SEJA ESTAMOS DIZENDO PEGUE TODOS OS USUÁRIOS CUJO O
firstname É Dani E O age É 14.

PARA FAZER CONDICIONAIS USANDO O OPERADOR ( || ) VAMOS PRECISAR DE UMA BIBIOTECA QUE VEM DO PRÓPRIO SEQUELIZE ...import { Op } from'sequelize'...

LOGO NOSSA BUSCA FICARÁ ASSIM:

let users = await User.findAll({
where: {
[Op.or]: [
{ firstname: 'Dani' },
{ age: 14 }
]
}
})
NOSSA BUSCA AGORA ESTÁ DIZENDO PEGE TODOS OS USUÁRIOS QUE TENHAM O firstname Dani OU age 14

===========================================================================

# USANDO OPERADORES NO SEQUELIZE

    SUPONDO AGORA QUE QUEREMOS PEGAR NO BANCO DE DADOS OS USUÁRIOS COM MAIS DE 40 ANOS.

NESTE CASO USAMOS O Op QUE JÁ IMPORTAMOS NA AULA PASSADA E DEFINIMOS QUAL PROPRIEDADE QUE QUEREMOS E QUAL É A CONDIÇÃO

export const home = async (req: Request, res:Response) => {
let users = await User.findAll({
where: {
age: {
[Op.gt]: 40 => MAIOR QUE
[Op.gte]: 40 => MAIOR OU IGUAL À
[Op.lt]: 40 => MENOR QUE
[Pp.lte]: 40 => MENOR OU JIGUAL À
}
}
})
}

NO CÓDIGO ACIMA A SIGLE gt QUER DIZER greater than(MAIOR QUE) E A SIGLA lte QUER DIZER greater than or equal(MAIOR OU IGUAL À) 40 NO NOSSO CASO...
PARA FILTRAR USANDO MAIS DE UMA CONDIÇÃO , NECESSITAMOS APENAS ADICIONAR UMA (,) DEPOIS DE CADA PROPRIEDADE COMO NO EXEMPLO ABAIXO:

[op.gt]: 40,
[op.lt]: 75

    NESTE CÓDIGO  ESTAMOS FILTRANDO POR 2 CONDIÇÕES... MAIOR QUE 40 E MENOR QUE 75 ASSIM ELE VAI NOS TRAZER TODOS OS USUÁRIOS QUE TEM MAIS DE 40 E MENOS DE 75.

PARA O MESMO RESULTADO TAMBÉM PODEMOS USAR O between:

[Op.between]: [40,75] QUE VAI NOS TRAZER TODO OS USUÁRIOS COM IDADE ENTRE 40 E 75

QUANDO BUSCAMOS UM USUÁRIO OU UMA INFORMAÇÃO QUE NÃO TEMOS O NOME INTEIRO DA INFORMAÇÃO QUE QUEREMOS EX:

export const home = async (req: Request, res:Response) => {
let users = await User.findAll({
where: {
firstname: {
[Op.like]: 'Th%'
}
}
})
}

NESTE CASO ESTAMOS BUSCANDO INFORMSÇÕES OU USUÁRIOS QUE COMEÇEM COM (Th)...

PORÉM SE EU QUISER BUSCAR POR INFORMAÇÕES OU USUÁRIOS QUE TENHAM (Th) EM QUALQUER PARTE DO NOME????POR EXEMPLO O USUÁRIO DO MEU SISTEMA QUE BUSCAR O NOME Thonwelling
E SUAS RESPECTIVAS INFORMAÇÕES PORÉM ELE NÃO SE LEMBRA DO NOME POR COMPLETO ELE LEMBRA QUE NO NOME TEM (Th) ENTÃO ELE VAI NO CAMPO DE BUSCA(input) DO SISTEMA E DIGITA
SOMENTE A PARTE DO NOME QUE ELE SE RECORDA OU SEJA (Th) COMO EU FAÇO PARA PEGAR ESSA INFORMAÇÃO QUE ELE DIGITOU E FAZER A BUSCA E APRESENTAR UM RESULTADO VALIDO PARA
ELE ????

PRIMEIRO PEGAMOS A INFORMAÇÃO QUE O USUÁRIO DIGITOU NO CAMPO DE BUSCA E ARMAZENAMOS EM UMA VARIÁVEL

export const home = async (req: Request, res:Response) => {
let searchName: string = 'Th' ESSA STRING PODE SER PEGA COM REACT ATRAVÉS DE UMA FUNÇÃO QUE RECEBE UM (e) E PASSA NO SCOPO DA FUNÇÃO O e.target.value
let users = await User.findAll({
where: {
firstname: {
[Op.like]: `%${searchName}%`

    }

}
})
}

===========================================================================

# ORDENAÇÃO E LIMITAÇÃO DE RESULTADOS

SUPONDO AGORA QUE NÓS TEMOS UMA LISTA DE PRODUTOS EM ESTOQUE E QUEREMOS ORDENÁ-LOS.COMO FAZEMOS ISSO????

    PARA ISSO DEPOIS DE where  ADICIONAMOS UMA VIRGULA (,) E COLOCAMOS A PROPRIEDADE order E DENTRO DE UM ARRAY COLOCAMOS ONDE SERÁ A BUSCA NO NOSSO CASO (firstname)  E EM SEGUIDA QUAL SERÁ A ORDEM,

'ESC' para ordenar em ordem alfabetica ascendente
'DESC' para ordenar em ordem alfabetica descecendente

let users = await User.findAll({
where: {
age: {
[Op.gte]: 40
}
},
order: [
['firstname', 'ASC'],
['firstname', 'DESC']
]
})

E SE EU QUISER ORDENAR PRIMEIRO PELO NOME E DEPOIS PELA IDADE ???
SIMPLES, SÓ PRECISAMOS COLOCAR DENTRO DE ORDER

['firstname', 'ASC'],
['age', 'DESC']

SUPONDO QUE NÓS TENHAMOS UM BANCO DE DADOS COM 1 MILHÃO DE USUÁRIOS E QUEREMOS FAZER UMA BUSCA EM TODOS OS REGISTROS. SE USARMOS A FUNÇÃO findAll() ELA VAI RETORNAR TODOS
OS REGISTROS COMO APRENDEMOS ANTES PORÉM SÃO MUITOS REGISTROS (DADOS) E VAI HAVER UMA DEMORA MUITO GRANDE PARA SE TRAZER TODAS AS INFORMAÇÕES CORRENDO O RISCO ATÉ DE OCORRER
UM ERRO DE timeOut...
NESSES CASOS O IDEAL É TRAZER OS REGISTROS EM PARTES(OU LIMITAR) COMO PAGINAÇÃO...COMO FAZEEMOS ISSO ???

    DEPOIS DO order ADICINAMOS MAIS UMA (,) E COLOCAMOS A PROPRIEDADE limit E DETEREMINAMOS QUANTOS RESULTADOS TEREMOS POR PÁGINA..
    PARA EXIBIR  OUTRA PÁGINA DE RESULTADOS  INSERIMOS UMA (,) E ADICIONAMOS A PROPRIEDADE  offset E DETERMINAMOS A QUANTIDADE DE RESULTADOS QUE VAMOS PULAR (NÃO VAMOS EXIBIR).

EX:

    offset: 4,  => quantos itens ele vai pular
         limit: 2   => quantos itens  ele vai exibir por página

===========================================================================

# INSERINDO DADOS COM SEQUELIZE

    EXISTEM 2 FORMAS DE INSERIR DADOS USANDO O SEQUELIZE SÃO ELAS :
    	BUILD + SAVE   E O CREATE


    	BUILD + SAVE

    PARA CRIAR UM NOVO USUÁRIO COM O MÉTODO BUILD + SAVE, CRIAMOS UMA CONSTANTE NO NOSSO CASO user E ATRIBUIMOS O NOSSO MODEL User E DAMOS (.)A FUNÇÃO build() E DENTRO DESSE BUILD

PASSAMOS AS INFORMAÇÕES QUE QUEREMOS:LEMBRANDO QUE O id ESTÁ SENDO CRIADO AUTOMATICAMENTE.

const user = User.build({
firstname: 'Walisson',
lastname: 'Oliveira',
age: 32
})

ESSE CÓDIGO CRIA UMA INSTÂNCIA DO NOVO USUÁRIO DENTRO DO SEU CÓDIGO MAIS NÃO SALVA NO BANCO DE DADOS...
ENTÃO COMO EU FAÇO PARA ADICIONAR ESSE USUÁRIO NOVO NO MEU BANCO DE DADOS???

SIMPLES: USANDO A FUNÇÃO .save().NÓS USAMOS O await (PORQUE ESTAMOS FAZENDO UM TIPO DE REQUISIÇÃO AO BANCO DE DADOS) PARA RQUISITAR AO BANCO DE DADOS QUE SEJA ADICIONADO OU (SALVO)
O NOVO REGISTRO(USUÁRIO).

    		CREATE
    PARA CRIAR UM NOVO USUÁRIO COM O MÉTODO CREATE, CRIAMOS UMA CONSTANTE NO NOSSO CASO user E ATRIBUIMOS O NOSSO MODEL User E DAMOS (.)A FUNÇÃO create() E DENTRO DESSE BUILD

PASSAMOS AS INFORMAÇÕES QUE QUEREMOS:LEMBRANDO QUE O id ESTÁ SENDO CRIADO AUTOMATICAMENTE.

const user = await User.create({
id: 14,
firstname: 'Ingrid',
lastname: 'Oliveira',
age: 30
})

NOTE QUE NESSE MÉTODO PRECISAMOS USAR O await JUNTAMENTE COM O NOSSO model E LOGO EM SEGUIDA A FUNÇÃO POR UM SIMPLES MOTIVO ...
O MÉTODO CREATE JA FAZ DIRETAMENTE A REQUISIÇÃO E SINCRONIZAÇÃO COM O BANCO DE DADOS SEM PRECISAR DA FUNÇÃO save().

ENTÃO QUAL É A DIFERENÇA ENTRE OS 2 MÉTODOS ???
O MÉTODO build + save PODE SER USADO PARA IR MONTANDO A S INFORMAÇÕES DO USUÁRIO GRADATIVAMENTE.
EX: CRIAMOS O USUÁRIO SOMENTE COM O firstname E O lastname E NÃO TEMOS A IDADE DO USUÁRIO MAIS TEMOS A SUA DATA DE NASCIMENTO NO MÉTODO build + save PODEMOS FAZER UMA MANIPULAÇÃO  
PARA TRANSFORMAR A DATA DE NASCIMENTO EM IDADE E ARMAZENAMOS O RESULTADO DESSA MANIPULAÇÃO EM UMA VARIÁVEL E DEPOIS MANDAMOS COMO PROPRIEDADE.
EXEMPLO:

const user = User.build({
id: 15,
firstname: 'Aluno',
lastname: 'Suquinho'
})
let currentYear = getFullYear()
let burnDate = 2021
let idade = currentYear - burnDate

    user.age = idade

    await user.save()

===========================================================================

# ATUALIZANDO DADOS NO BANCO COM SEQUELIZE

    EXISTEM 2 FORMAS DE FAZER ATUALIZAÇÕES EM DADOS JÁ EXISTENTES NO BANCO

1º SERIA UMA FORMA MAIS GERAL
2º SELECINAMOS UM REGISTRO E PRE SELECIONAMOS UM ITEM ESPECÍFICO DO REGISTRO

# ATUALIZANDO A PRIMEIRA FORMA :FORMA GERAL (ATUALIZA TODO E QUALQUER DADOS QUE SATISFAÇA A UMA DETERMINADA CONDIÇÃO)

PARA ISSO USAREMOS A FUNÇÃO UPDATE.
ESSA FUNÇÃO TEM 2 PARÂMETROS SENDO QUE: O 1º SÃO OS DADOS A SEREM ALTERADOS E
O 2º SÃO AS CONDIÇÕES PARA ENCONTRAR O(OS) ITEM(NS)

await User.update({ lastname: 'Xico'}, {
where: {
id: 15
}
})

# ATUALIZANDO DADOS DE 1 USUÁRIO (REGISTRO) ESPECÍFICO

A PRIMEIRA COISA QUE TEMOS QUE FAZER É: SELECIONAR O USUÁRIO(OU REGISTRO) QUE QUEREMOS ATUALIZAR O(OS) DADO(OS) PARA ISSO UMA DAS FORMAS QUE PODEMOS UTILIZAR É UTILIZANDO O MÉTODO findAll()
NO EXEMPLO ABAIXO ESTAMOS SELECIONANDO O USUÁRIO COM O ID DE Nº 12

    let results = await User.findAll({ where: {id: 12}})

    CONTUDO NÓS NÃO PODEMOS FAZER ALTERAÇÕES EM UM ARRAY E O MÉTODO findAll() SEMPRE RETORNA UM ARRAY MESMO QUE ESSE ARRAY CONTENHA APENAS 1 REGISTRO.

NESTE CASO PRECISAMOS SELECIONAR O USUÁRIO EM SI E NÃO UM ARRAY COM 1 USUÁRIO QUE É OQUE TEMOS NESTE EXATO MOMENTO,ENTÃO , COMO FAZEMOS ISSO???
PRIMEIRO VERIFICAMOS SE O MÉTODO NOS TROUXE ALGUM RESULTADO E EM SEGUIDA PEDIMOS PERA ELE PEGAR(SELECIONAR O 1º REGISTRO).

VEJA ABAIXO:
if(results.length > 0) {
let user = results[0]
}

    AGORA VAMOS FAZER AS ALTERAÇÕES.NO NOSSO CASO VAMOS MODIFICAR O SOBRENOME DO USUÁRIO QUE ESTÁ NO REGISTRO QUE SELECIONAMOS.PARA FAZER ISSO ADICIONAMOS AO CÓDIGO  OS SEGUINTES COMANDOS:

    usuario.lastname = 'Neves'
    await usuario.save()

===========================================================================

# DELETANDO DADOS COM SEQUELIZE

PARA FAZER O PROCESSO DE DELETAR VAMOS USAR O MESMO PRINCÍPIO QUE USAMOS PARA ATUALIZAR OU SEJA AQUELAS 2 MANEIRAS DE SE FAZER

    DELETANDO DA PRIMEIRA FORMA :FORMA GERAL DELETA TODO E QUALQUER DADOS QUE SATISFAÇA A UMA DETERMINADA CONDIÇÃO)

PARA ISSO VAMOS UTILIZAR O COMANDO destroy().
O COMANKDO destroy() TEM APENAS 1 PARÂMETRO PORQUE ELE NÃO VAI MODIFICAR NADA COMO NO update() ELE SÓ PRECISA DE CONDIÇÃO PARA ENCONTRAR O DADO QUE ELE VAI DELETAR.

    await User.destroy({
    where: {
      id: 10,
      firstname: 'Bianca'
    }

})

# DELETANDO DADOS DE 1 USUÁRIO (REGISTRO) ESPECÍFICO

A PRIMEIRA COISA QUE TEMOS QUE FAZER É: SELECIONAR O USUÁRIO(OU REGISTRO) QUE QUEREMOS ATUALIZAR O(OS) DADO(OS) PARA ISSO UMA DAS FORMAS QUE PODEMOS UTILIZAR É UTILIZANDO O MÉTODO findAll()
NO EXEMPLO ABAIXO ESTAMOS SELECIONANDO O USUÁRIO COM O NOME Matheus

    let results = await User.findAll({ where: {firstname: 'Matheus'}})

    CONTUDO NÓS NÃO PODEMOS FAZER ALTERAÇÕES EM UM ARRAY E O MÉTODO findAll() SEMPRE RETORNA UM ARRAY MESMO QUE ESSE ARRAY CONTENHA APENAS 1 REGISTRO.

NESTE CASO PRECISAMOS SELECIONAR O USUÁRIO EM SI E NÃO UM ARRAY COM 1 USUÁRIO QUE É OQUE TEMOS NESTE EXATO MOMENTO,ENTÃO , COMO FAZEMOS ISSO???
PRIMEIRO VERIFICAMOS SE O MÉTODO NOS TROUXE ALGUM RESULTADO E EM SEGUIDA PEDIMOS PERA ELE PEGAR(SELECIONAR O 1º REGISTRO).
VEJA ABAIXO:

    	if(results.length > 0) {
    		let user = results[0]
    	}

    AGORA VAMOS DELETAR ESTE REGISTRO(USUÁRIO)

    await user.destroy()

=========================================================================

## EXERCÍCIO:

CRIE PARA CADA USUÁRIO DA LISTA 3 BOTÕES...1 PARA ADICIONAR IDADE 1 PARA SUBTRAIR IDADE E 1 PARA DELETAR O USUÁRIO.

## RESOLUÇÃO :

## 1º

DE TUDO VAMOS NO NOSSO ARQUIVO DA HOME ONDE EXIBIMOS A LISTA DE USUÁRIOS E CRIAREMOS OS 3 BOTÕES(links <a></a>) CADA UM COM SEU NOME OU SÍMBOLO.

## 2º

NO ATRIBUTO DETERMINEMOS O NOME DA ROTA <a href="/usuario/{{id}}/mais"> USAREMOS O {{id}} PARA SELECIONAR O PRÓPRIO USUARIO DA LISTA

## 3º

VAMOS NO NOSSO ARQUIVO DE ROTAS ./routes/index.ts E CRIEMOS AS ROTAS PARA CADA UM DELES
router.get('/usuario/:id/mais',)
router.get('/usuario/:id/menos',)
router.get('/usuario/:id/delete',)

## 4º

VAMOS PARA O CONTROLLER NO CASO COMO SE TRATA DE USUÁRIOS VAMOS PARA O UserController E VAMOS CRIAS AS FUNÇÕES QUE VÃO EXECUTAR CADA AÇÃO.COMO NÃO TEMOS NADA VISUAL NESTAS 3 ROTAS (NÃO HÁ MUDANÇA DE TELA) NÃO DAMOS UM res.render() E SIM DAMOS UM REDIRECT
DEVOLTA PARA A HOME COM res.redirect('/')

    	export const addIdade = (req: Request, res: Response) => {

      res.redirect('/')
    	}
    	export const diminuiIdade = (req: Request, res: Response) => {

      res.redirect('/')
    	}
    	export const excluir = (req: Request, res: Response) => {

      res.redirect('/')
    	}

## 5º

AGORA ADICIONAMOS OS CONTROLLERS NO SEGUNDO PARÂMETRO DAS NOSSAS ROTAS:
router.get('/usuario/:id/mais',UserController.addIdade)
router.get('/usuario/:id/menos',UserController.diminuiIdade)
router.get('/usuario/:id/delete',UserController.excluir)

## 6º

ANTES DE APLICAR QUALQUER AÇÃO NO USUÁRIO EU PRECISO SABER QUAL É O USUÁRIO E COMO EU ESTOU MANDANDO NA URL EU RECEBO EM req.params.PARA VER OS PARAMS DE UM console>log('PARAMS: ', req.params)
SE MOSTRAR NO SEU CONSOLE OS PARAMETROS NO NOSSO CASO O id É PORQUE DEU TUDO CERTO ESTAMOS RECEBENDO CORRETAMENTE.

## 7º

PEGUE O ID DO USUÁRIO USANDO O req.params E ATRIBUA À UMA VARIÁVEL NÃO SE ESQUEÇA DE TIPAR A VARIÁVEL. ASSIM let id:string = req.params.id .
---PRECISAMOS IMPORTAR O NOSSO MODEL DENTRO DO NOSSO CONTROLLER PARA PODER USAR.

## 8º

VAMOS FAZER AGORA A ATUALIZAÇÃO DO DADO ESCOLHIDO UTILIZANDO A FORMA DE ATUALIZAR DADOS DE UM USUÁRIO(REGISTRO) ESPECÍFICO.
##10º
FAREMOS AGORA A FUNÇÃO diminuirIdade QUE É EXATAMENTE O MESMO CÓDIGO COM A DIFERENÇA QUE NO LUGAR DO ++ VAMOS USAR -- .
##10º
FAREMOS AGORA O EXCLUIR QUE É EXATAMENTE O MESMO CÓDIGO COM A DIFERENÇA QUE NÃO PRECISAMOS ATUALIZAR E NEM MODIFICAR NENHUM DADO E NÃO USAREMOS O user.save() MAIS SIM O user.destroy().

===========================================================================

# MÉTODOS FINDER

    ATÉ AGORA ESTAVAMOS USANDO  APENAS O findAll() PORÉM EXISTEM OUTRAS FORMAS DE ENCONTRAR INFORMAÇÕES NO BANCO DE MANEIRA MAIS PRÁTICA.

## findOne()

    USAMOS ESSE MÉTODO FINDER PARA ENCONTRAR APENAS 1 REGISTRO E POR ISSO ELE NÃO TEM PORQUE RETORNAR UM ARRAY COMO O findAll() ELE RETORNA DIRETAMENTE O OBJETO DO USUÁRIO ENCONTRADO.

O MODO DE USAR É EXATAMENTE IGUAL AO findAll().
EX:
let usuario = await User.findOne({
where: {
id: 1
}
})
if(usuario) { => ESTE IF VERIFICA SE EXISTE O OBJETO usuario
console.log(`O Usuário ${user.firstname} Tem {user.age} Anos`)
} else {
console.log('Usuário não encontrado')
}

## \*\*\*OBS: NO CASO DE USARMOS UMA CONDIÇÃO QUE PODERIA TRAZER MAIS DE UM REGISTRO(USUÁRIO) ELE PEGARÁ SOMENTE O PRIMEIRO REGISTRO ENCONTRADO.

    	let usuario = await User.findOne({
    	  where: {
    	      [Op.gt]: 18
    	  }
    	})

if(usuario) { => ESTE IF VERIFICA SE EXISTE O OBJETO usuario
console.log(`O Usuário ${user.firstname} Tem {user.age} Anos`)
} else {
console.log('Usuário não encontrado')
}
O RESULTADO SERIA NO CONSOLE ===> O Usuàrio Thonwelling Tem 36 Anos

## findByPK()

    ESTE É USADO QUANDO TEMOS O id DO USUÁRIO QUER DIZER ENCONTRE PELO PrimaryKey
    	let usuario = await User.findByPK(2)

if(usuario) { => ESTE IF VERIFICA SE EXISTE O OBJETO usuario
console.log(`O Usuário ${user.firstname} Tem {user.age} Anos`)
} else {
console.log('Usuário não encontrado')
}
O RESULTADO SERIA NO CONSOLE ===> O Usuàrio Dani Tem 36 Anos
